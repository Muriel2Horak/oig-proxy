============================= test session starts ==============================
platform darwin -- Python 3.14.3, pytest-9.0.2, pluggy-1.6.0 -- /opt/homebrew/opt/python@3.14/bin/python3.14
cachedir: .pytest_cache
rootdir: /Users/martinhorak/Projects/oig-proxy
configfile: pytest.ini
plugins: mock-3.15.1, asyncio-1.3.0, cov-7.0.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 1 item

tests/test_proxy_control_more.py::test_nack_with_wrong_conn_id_is_ignored FAILED [100%]

=================================== FAILURES ===================================
___________________ test_nack_with_wrong_conn_id_is_ignored ____________________

tmp_path = PosixPath('/private/var/folders/vj/680smcyn26b89dfkt2hsp96m0000gn/T/pytest-of-martinhorak/pytest-29/test_nack_with_wrong_conn_id_i0')

    def test_nack_with_wrong_conn_id_is_ignored(tmp_path):
        """
        RED TEST: NACK with wrong conn_id should be ignored.
    
        Scenario:
          1. Setting delivered on conn_id=1, pending state stored with conn_id=1
          2. Connection closes, new connection conn_id=2 opens
          3. NACK arrives on conn_id=2 (wrong connection)
          4. NACK should be IGNORED, pending state should remain
    
        Expected: FAIL - current code does not validate conn_id ownership
        """
        proxy = make_proxy(tmp_path)
        writer1 = DummyWriter()  # Original connection (conn_id=1)
        writer2 = DummyWriter()  # New connection after reconnect (conn_id=2)
        proxy._active_box_writer = writer1
        proxy._ctrl.ack_timeout_s = 10.0
        ack_results = []
    
        async def fake_ack(**kwargs):
            ack_results.append(kwargs)
    
        proxy._ctrl.on_box_setting_ack = fake_ack
    
        async def run():
            # Step 1: Send setting on conn_id=1
            res = await proxy._cs.send_to_box(
                tbl_name="tbl_box_prms",
                tbl_item="BAT_AC",
                new_value="1",
                confirm="New",
                tx_id="tx2",
            )
            assert res["ok"] is True
            assert proxy._cs.pending is not None
    
            # Mark as delivered on conn_id=1
            proxy._cs.pending["sent_at"] = time.monotonic()
            # Store the conn_id where it was delivered (this should be part of pending)
            proxy._cs.pending["delivered_conn_id"] = 1
    
            # Step 2: Simulate connection switch (reconnect)
            # Setting was sent on conn_id=1, now connection is conn_id=2
            proxy._active_box_writer = writer2
    
            # Step 3: NACK arrives on WRONG connection (conn_id=2)
            # This NACK should be IGNORED because setting was delivered on conn_id=1
            ok = proxy._cs.maybe_handle_ack(
                "<Reason>Setting</Reason><Result>NACK</Result>",
                writer2,
                conn_id=2,  # Wrong connection!
            )
    
            await asyncio.sleep(0)
    
            # Step 4: Assert NACK was IGNORED
            # FAIL: Current code clears pending regardless of conn_id mismatch
            assert ok is False, "NACK with wrong conn_id should return False (ignored)"
            assert proxy._cs.pending is not None, "Pending state should NOT be cleared for wrong conn_id"
            assert ack_results == [], "on_box_setting_ack should NOT be called for wrong conn_id"
    
>       asyncio.run(run())

tests/test_proxy_control_more.py:615: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/homebrew/Cellar/python@3.14/3.14.3_1/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/runners.py:204: in run
    return runner.run(main)
           ^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.14/3.14.3_1/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/runners.py:127: in run
    return self._loop.run_until_complete(task)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.14/3.14.3_1/Frameworks/Python.framework/Versions/3.14/lib/python3.14/asyncio/base_events.py:719: in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def run():
        # Step 1: Send setting on conn_id=1
        res = await proxy._cs.send_to_box(
            tbl_name="tbl_box_prms",
            tbl_item="BAT_AC",
            new_value="1",
            confirm="New",
            tx_id="tx2",
        )
        assert res["ok"] is True
        assert proxy._cs.pending is not None
    
        # Mark as delivered on conn_id=1
        proxy._cs.pending["sent_at"] = time.monotonic()
        # Store the conn_id where it was delivered (this should be part of pending)
        proxy._cs.pending["delivered_conn_id"] = 1
    
        # Step 2: Simulate connection switch (reconnect)
        # Setting was sent on conn_id=1, now connection is conn_id=2
        proxy._active_box_writer = writer2
    
        # Step 3: NACK arrives on WRONG connection (conn_id=2)
        # This NACK should be IGNORED because setting was delivered on conn_id=1
        ok = proxy._cs.maybe_handle_ack(
            "<Reason>Setting</Reason><Result>NACK</Result>",
            writer2,
            conn_id=2,  # Wrong connection!
        )
    
        await asyncio.sleep(0)
    
        # Step 4: Assert NACK was IGNORED
        # FAIL: Current code clears pending regardless of conn_id mismatch
>       assert ok is False, "NACK with wrong conn_id should return False (ignored)"
E       AssertionError: NACK with wrong conn_id should return False (ignored)
E       assert True is False

tests/test_proxy_control_more.py:611: AssertionError
=========================== short test summary info ============================
FAILED tests/test_proxy_control_more.py::test_nack_with_wrong_conn_id_is_ignored
============================== 1 failed in 0.11s ===============================
